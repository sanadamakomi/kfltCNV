#' @title Perform calculating depth of coverage.
#' @description Input a BAM file or files to calculate the total bases
#'   overlapping the region. Sequencing depth of coverage in this region equals
#'   to total bases divide by width of region.
#' @details The input BAM file need a BAM index file (<filename>.bai). The index
#'   file can be generated by \emph{samtools} or other BAM/SAM tools after
#'   sorting. Function will stop if the BAM file lose an index file or its index
#'   file is older than its own.
#'
#'   If \emph{bedFile} is not \code{NULL}, it will be splited unless the
#'   \emph{width} option is also \code{NULL}. If a BED file is not provided,
#'   windows will be created from the whole genome, by default 100,000 bp each
#'   window. Coverage of depth will be calculated by each window. Three required
#'   BED fields are chromosome name, start and end position.
#'
#'   It can perform in multithreading with number of threads you input. If the
#'   \emph{thread} is over 1, it will perform in multithreading, default by
#'   single thread. Multithreading uses \code{parLapply()} function in
#'   \pkg{parallel} package and it can run on Linux but not Windows system. And
#'   the \emph{batch} option limits the number of GRanges in a batch to run in a
#'   thread.
#'
#'   The result are coverage files (<filename>.cov) which have four columns
#'   indicating chromosome name, chromosome start, chromosome end and depth of
#'   coverage, without a header line.
#' @param bamFiles A character string or vector of the BAM files path.
#' @param bedFile A BED file path.
#' @param outDir A character string of directory to output coverage files
#'   (<filename>.cov). Default is the current folder.
#' @param width An integer giving the width of each window, such as
#'   \strong{1E2}, \strong{1e2} or \strong{100}.
#' @param thread An integer providing the number of thread.
#' @param batch An integer giving how many GRanges are performed in a batch.
#' @param mapq.filter A non-negative integer specifying the minimum mapping
#'   quality to include. BAM reads with mapping qualities less than mapqFilter
#'   are discarded.
#' @export
#' @import IRanges
#' @import GenomicRanges
#' @import S4Vectors
#' @import GenomicAlignments
#' @import Biostrings
#' @importFrom Rsamtools BamFile
#' @author Zhan-Ni Chen
#' @examples
#' ####### Perform calculating depth of coverage #######
#' performCreateCovFile(
#'   bamFiles = system.file("extdata", 'testSample.bam', package = "kfltCNV"),
#'   bedFile = system.file("extdata", 'chr10_exome.bed', package = "kfltCNV"))
performCreateCovFile <- function(bamFiles, bedFile = NULL, outDir = NULL, width = NULL, thread = 1, batch = 1000, mapq.filter = 30) {
    if (is.null(outDir)) outDir <- '.'
    if (! file.exists(outDir)) dir.create(outDir)
    outDir <- normalizePath(outDir)
    # check bams
    checkBam(bamFiles)
    genomeseqinfo <- seqinfo(BamFile(bamFiles[1]))

    # Region
    if (! is.null(bedFile)) {
        write('Use target region BED file to calculate coverage.', stdout())
        if (! file.exists(bedFile)) stop(paste0(bedFile, " no exists."))
        if (is.null(width)) {
            write('Target will not be splited', stdout())
            region <- bedtoGRange(bedFile, genomeSeqinfo = genomeseqinfo)
        } else {
            write(paste0('Target will be splited, ', width, " bp each window."), stdout())
            region <- splitBed(bedFile, width = width, genomeSeqinfo = genomeseqinfo)
        }
    } else {
        write('Use the whole Genome region to calculate coverage.', stdout())
        if (is.null(width)) {
            warning('Genome will be splited, 100,000 bp (default) each window.')
            region <- splitGenome(genomeseqinfo, width = 1E5)
        } else {
            write(paste0('Genome will be splited, ', width, " bp each window."), stdout())
            region <- splitGenome(genomeseqinfo, width = width)
        }
    }

    # do bams
    write('Perform calculating coverage.', stdout())
    for (bam in bamFiles) {
        write(paste0('Perform BAM:\n', bam), stdout())
        id <- rev(unlist(strsplit(bam, "/")))[1]
        id <- unlist(strsplit(id, "\\."))[1]
        if (thread > 1) {
            out <- depthOfRegionMultiCore(region = region, bamPath = bam, thread = thread, batch = batch, mapq.filter = mapq.filter, tmpDir = outDir)
        } else {
            out <- depthOfRegion(region = region, bamPath = bam, mapq.filter = mapq.filter)
        }
        writeCovFile(out, path = paste0(outDir, "/",  id, ".cov"))
    }
    write('Done.', stdout())
}

#' @title Calculate depth of coverage in a given region.
#' @description Input a BAM file and a GenomicRanges object of given region,
#'   calculate the total bases overlapping this region. Sequencing depth of
#'   coverage of region equals total bases divide by width of region.
#'
#'   The input BAM file need a BAM index file (<filename>.bai). The index file
#'   can be generated by \emph{samtools} or other BAM/SAM tools after sorting.
#'   Function will stop if the BAM file lose an index file or its index file is
#'   older than its own.
#'
#'   \code{depthOfRegionMultiCore()} can perform in multithreading with number
#'   of threads you input. Multithreading uses \code{parLapply()} function in
#'   \pkg{parallel} package and it can run on Linux but not Windows system. And
#'   the \emph{batch} option limits the number of GRanges in a batch to run in a
#'   thread.
#' @param region a GenomicRanges object.
#' @param bamPath a character string of the BAM file path.
#' @param mapq.filter a non-negative integer specifying the minimum mapping
#'   quality to include. BAM records with mapping qualities less than mapqFilter
#'   are discarded.
#' @param thread an integer providing the number of threads just for
#'   \code{depthOfRegionMultiCore()}.
#' @param batch an integer giving how many GRanges are performed in a batch just
#'   for \code{depthOfRegionMultiCore()}.
#' @param tmpDir a character string of the directory path to write to.
#' @return A GenomicRanges object with a column named depth representing the
#'   sequencing depth of this region.
#' @export
#' @import parallel
#' @import IRanges
#' @import GenomicRanges
#' @import S4Vectors
#' @import GenomicAlignments
#' @importFrom GenomicAlignments start
#' @importFrom GenomicAlignments end
#' @importFrom GenomicAlignments width
#' @importFrom Rsamtools BamFile
#' @importFrom Rsamtools scanBamFlag
#' @author Zhan-Ni Chen
#' @examples
#' ####### Calculate depth of coverage in a given region #######
#' require(GenomicRanges)
#' depthOfRegion(
#' region = GRanges(Rle("10"), IRanges(start = 27444268, end = 27444388)),
#' bamPath = system.file("extdata", 'testSample.bam', package = "kfltCNV"))
depthOfRegion <- function(region, bamPath, mapq.filter = 30) {
    what <- c("mapq", "flag")
    flag <- scanBamFlag(isUnmappedQuery = FALSE, isSecondaryAlignment = FALSE, isDuplicate = FALSE)
    param <- ScanBamParam(which = region, what = what, flag = flag, mapqFilter = mapq.filter)
    inBam <- readGAlignments(file = bamPath, index = bamPath, param = param)
    binCov <- coverage(IRanges(start = start(inBam), width = width(inBam)))
    binCovView <- Views(binCov, start = start(region), width = width(region))
    totalCov <- viewSums(binCovView, na.rm = TRUE)
    depth <- totalCov/width(region)
    bamseqinfo <- seqinfo(BamFile(bamPath))
    GRanges(Rle(seqnames(region)), IRanges(start = start(region) , end = end(region)),
        seqinfo = bamseqinfo, depth = depth)
}

#' @rdname depthOfRegion
#' @export
depthOfRegionMultiCore <- function(region, bamPath, thread, batch, mapq.filter = 30, tmpDir = NULL) {
    timestamp <- paste0('depth', as.character(as.integer(Sys.time())))
    if (is.null(tmpDir)) tmpDir <- '.'
    tmp <- normalizePath(tmpDir)
    tmp <- paste0(tmp, '/tmp_', timestamp)
    if (! file.exists(tmp) ) dir.create(path = tmp)
    batch.index <- IRanges(breakInChunks(totalsize = length(region),  chunksize = batch))
    chunks <- GRangesList()
    for (i in 1:length(batch.index)) {
        chunks[[i]] <- region[start(batch.index)[i]:end(batch.index)[i]]
    }
    clsp <- makeCluster(thread, type = "FORK", outfile = paste0(tmp, "/log.txt"))
    a <- parLapply(clsp, chunks, function(gr, ...) {
        gr <-  depthOfRegion(gr, bamPath, mapq.filter = mapq.filter)
        save(gr, file = paste0(tmp, "/", timestamp, "_", seqnames(gr)[1], "_", min(start(gr)), "_", max(end(gr)),".Rdata"))
    })
    stopCluster(clsp)
    allrdata <- list.files(path = tmp, pattern = ".Rdata", all.files = TRUE, full.names = TRUE, recursive = FALSE, include.dirs = FALSE)
    result <- GRangesList()
    for (i in 1:length(allrdata)) {
        gr <- get(load(allrdata[i]))
        result[[i]] <- gr
    }
    unlink(tmp, recursive = TRUE)
    unlist(result)
}
